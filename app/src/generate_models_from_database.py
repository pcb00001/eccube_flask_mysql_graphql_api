import MySQLdb
import inspect

import generate_config as config
import generate_util as util
import generate_cursor

common_import = ["""
# The file has been generated by tool- nguyennt2@rikkeisoft.com
from config.database import Base
from sqlalchemy import Column, DECIMAL, DateTime, ForeignKey, Index, String, text
from sqlalchemy.dialects.mysql import DECIMAL, INTEGER, SMALLINT, TINYINT, LONGTEXT, TEXT
from sqlalchemy.orm import relationship\n
"""]



def convertSqlDataTypeToSqlalchemyType(sql_data_type):
    switcher = {
        "int": "INTEGER",
        "tinyint": "TINYINT",
        "smallint": "SMALLINT",
        "bigint": "BIGINT",
        "varchar": "String",
        "datetime": "DateTime",
        "decimal": "DECIMAL",
        "text": "TEXT",
        "longtext": "LONGTEXT"
    }
    return switcher.get(sql_data_type, "Invalid sql data type")


def buildKey(column_key):
    switcher = {
        "PRI": ", primary_key=True",
        "UNI": ", unique=True"
    }
    return switcher.get(column_key, "")


def buildIndex(column_name, table_name):
    cursor_statistics = generate_cursor.connection.cursor(MySQLdb.cursors.DictCursor)
    cursor_statistics.execute(generate_cursor.query_check_index.format(column_name, table_name))
    constraint_info = cursor_statistics.fetchone()

    if constraint_info["has_index"] > 0:
        return ", index=True"
    else:
        return ""


def buildNullable(is_nullable):
    switcher = {
        "NO": ", nullable=False",
        "YES": ", nullable=True"
    }
    return switcher.get(is_nullable, "")


def buildComment(column_comment):
    if column_comment != "":
        return ", comment='{0}'".format(column_comment)
    else:
        return ""


def buildDefaultValue(column_default):
    if column_default is not None:
        return ", server_default=text(\"\'{0}\'\")".format(column_default)
    else:
        return ""


def buildDataTypeLength(data_type, character_maximum_length, numeric_precision, numeric_scale):
    if data_type == "longtext" or data_type == "datetime":
        return ""
    elif data_type == "decimal":
        return "({0}, {1})".format(numeric_precision, numeric_scale)
    else:
        if character_maximum_length is not None:
            return "({0})".format(character_maximum_length)
        elif numeric_precision is not None:
            return "({0})".format(numeric_precision)


def buildModel(table_name, cursor):
    import_packages = []

    model = [("\n\nclass Model{0}(Base):"
              "\n        __tablename__ = '{1}'\n").format(util.convertSnackToPascal(table_name), table_name)]

    for (column_name, data_type, character_maximum_length, numeric_precision, numeric_scale, is_nullable, extra,
         column_comment, column_key, column_default) in cursor:

        model.append(" \n        {0} = Column({1}".format(column_name, convertSqlDataTypeToSqlalchemyType(data_type)))
        model.append(buildDataTypeLength(data_type, character_maximum_length, numeric_precision, numeric_scale))

        # create new connection cursor for getting constraint information
        cursor_key_column_usage = generate_cursor.connection.cursor(MySQLdb.cursors.DictCursor)  # get the cursor
        cursor_key_column_usage.execute(generate_cursor.query_constraint.format(column_name, table_name))
        constraint_info = cursor_key_column_usage.fetchone()  # get only row

        if constraint_info is not None:
            model.append(
                buildForeignKey(constraint_info["referenced_table_name"], constraint_info["referenced_column_name"]))

        model.append(buildIndex(column_name, table_name))
        model.append(buildKey(column_key))

        model.append(buildNullable(is_nullable))
        model.append(buildDefaultValue(column_default))
        model.append(buildComment(column_comment))
        model.append(")")

        if constraint_info is not None:
            model.append("\n")
            if table_name != constraint_info["referenced_table_name"]:
                import_packages.append(
                    "from {2}.model_{0} import Model{1}\n".format(str.lower(constraint_info["referenced_table_name"]),
                                                                  util.convertSnackToPascal(
                                                                      constraint_info["referenced_table_name"]),
                                                                  config.model_folder))

            model.append(buildConstraint(table_name, column_name, constraint_info["referenced_table_name"],
                                         constraint_info["referenced_column_name"]))
            model.append("\n")

    return inspect.cleandoc("".join(common_import + import_packages + model))


def buildConstraint(primary_table_name, primary_foreign_key, referenced_table_name, referenced_primary_key):
    model_name = util.convertSnackToPascal(primary_table_name)
    referenced_model_name = util.convertSnackToPascal(referenced_table_name)
    backref = ""
    primary_join = ""

    if primary_table_name != referenced_table_name:
        backref = ", backref='{0}_list'".format(primary_table_name)
        primary_join = ", primaryjoin='Model{0}.{1} == Model{2}.{3}'".format(model_name, primary_foreign_key,
                                                                             referenced_model_name,
                                                                             referenced_primary_key)
    else:
        referenced_table_name = "parent_" + referenced_table_name

    return "        {0} = relationship('Model{1}'{2}{3})".format(referenced_table_name, referenced_model_name,
                                                                 primary_join, backref)


def buildForeignKey(referenced_table_name, referenced_column_name):
    return ", ForeignKey('{0}.{1}')".format(referenced_table_name, referenced_column_name)


def outModelFile(table_name, content_model):
    f = open("{0}/model_{1}.py".format(config.model_folder, table_name), "w+")
    f.write(util.black.format_str(content_model, mode=util.black.FileMode()))
    f.close()


for (table_name,) in generate_cursor.cursor:
    if len(config.list_tables) == 0 or table_name in config.list_tables:
        generate_cursor.cursor.execute(generate_cursor.query_column_info.format(table_name))
        outModelFile(table_name, buildModel(table_name, generate_cursor.cursor))
