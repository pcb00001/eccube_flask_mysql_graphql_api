import MySQLdb
import inspect

import generate_config as config
import generate_util as util
import generate_cursor

common_import = ["""
# The file has been generated by tool- nguyennt2@rikkeisoft.com

import graphene
from graphene_sqlalchemy import SQLAlchemyConnectionField
from datetime import datetime
from graphene_sqlalchemy import SQLAlchemyObjectType
from config.database import db_session
from common.util.graphene_util import input_to_dictionary
\n
"""]


def buildInputs(import_packages, model_name, cursor, queries_class):
    content_attribute = [
        "class {}Input(graphene.InputObjectType):".format(model_name)
    ]

    for (column_name, data_type, character_maximum_length, numeric_precision, numeric_scale, is_nullable, extra,
         column_comment, column_key, column_default) in cursor:
        content_attribute.append(
            '\t{0} = graphene.{1}(description="{2}", require={3})'.format(column_name,
                                                                          convertSqlDataTypeToGrapheneType(data_type),
                                                                          column_comment,
                                                                          is_nullable == 'YES'))

        # create new connection cursor for getting constraint information
        cursor_key_column_usage = generate_cursor.connection.cursor(MySQLdb.cursors.DictCursor)  # get the cursor
        cursor_key_column_usage.execute(generate_cursor.query_constraint.format(column_name, table_name))
        constraint_info = cursor_key_column_usage.fetchone()  # get only row

        queries_class.append(
            buildQueryAllByColumnName(column_name, convertSqlDataTypeToGrapheneType(data_type), table_name))

        queries_class.append(
            buildQueryFirstByColumnName(column_name, convertSqlDataTypeToGrapheneType(data_type), table_name))

        queries_class.append(
            buildQueryLimitByColumnName(column_name, convertSqlDataTypeToGrapheneType(data_type), table_name))

        queries_class.append(
            buildQueryLimit(table_name))

        queries_class.append(
            buildQueryAll(table_name))

        if constraint_info is not None:
            referenced_table_name = constraint_info['referenced_table_name']
            if table_name != referenced_table_name:
                import_packages.append('from {2}.schema_{0} import {1}Input'.format(referenced_table_name,
                                                                                    util.convertSnackToPascal(
                                                                                        referenced_table_name),
                                                                                    config.schema_folder))
                content_attribute.append(
                    '\n\t{0} = graphene.Field({1}Input)'.format(table_name, util.convertSnackToPascal(
                        referenced_table_name)))

    return "\n".join(content_attribute)


def buildConnection(model_name):
    return inspect.cleandoc("""
    \n\nclass {0}Connections(graphene.relay.Connection):
        class Meta:
            node = {0}""".format(model_name))


def buildMetaNode(model_name):
    return inspect.cleandoc("""
    \n\nclass {0}(SQLAlchemyObjectType):
        class Meta:
            model = Model{0}
            interfaces = (graphene.relay.Node,)
    """.format(model_name))


def buildQueryAllByColumnName(input_name, data_type, return_type):
    return (
        "\n get_all_{3}_by_{0} = graphene.Field(lambda: graphene.List({2}), {0}=graphene.{1}())"
        "\n def resolve_get_first_{3}_by_{0}(self, info, {0}):"
        "\n     query = {2}.get_query(info)"
        "\n     return query.filter(Model{2}.{0} == {0}).all()"
    ).format(input_name, data_type, util.convertSnackToPascal(return_type), return_type)


def buildQueryFirstByColumnName(input_name, data_type, return_type):
    return (
        "\n get_first_{3}_by_{0} = graphene.Field({2}, {0}=graphene.{1}())"
        "\n def resolve_get_first_{3}_by_{0}(self, info, {0}):"
        "\n     query = {2}.get_query(info)"
        "\n     return query.filter(Model{2}.{0} == {0}).first()"
    ).format(input_name, data_type, util.convertSnackToPascal(return_type), return_type)


def buildQueryLimitByColumnName(input_name, data_type, return_type):
    return (
        "\n get_limit_{3}_by_{0} = graphene.Field(lambda: graphene.List({2}), {0}=graphene.{1}(), offset=graphene.Int(), limit=graphene.Int())"
        "\n def resolve_get_limit_{3}_by_{0}(self, info, {0}, offset, limit):"
        "\n     query = {2}.get_query(info)"
        "\n     return query.filter(Model{2}.{0} == {0}).offset(offset).limit(limit).all()"
    ).format(input_name, data_type, util.convertSnackToPascal(return_type), return_type)


def buildQueryLimit(return_type):
    return (
        "\n get_limit_{1} = graphene.Field(lambda: graphene.List({0}), offset=graphene.Int(), limit=graphene.Int())"
        "\n def resolve_get_limit_{1}(self, info, offset, limit):"
        "\n     query = {0}.get_query(info)"
        "\n     return query.offset(offset).limit(limit).all()"
    ).format(util.convertSnackToPascal(return_type), return_type)


def buildQueryAll(return_type):
    return (
        "\n all_{1} = graphene.Field(lambda: graphene.List({0}))"
        "\n def resolve_all_{1}(self, info):"
        "\n     query = {0}.get_query(info)"
        "\n     return query.all()"
    ).format(util.convertSnackToPascal(return_type), return_type)


def buildQueryBySQLAlchemyConnectionField(return_type):
    return (
        "\n # List all DtbAuthorityRole"
        "\n get_all_{1} = SQLAlchemyConnectionField({0}Connections)"
    ).format(util.convertSnackToPascal(return_type), return_type)


def buildMutationInsert(model_name):
    return """\n\nclass Create{0}(graphene.Mutation):
    \"\"\"Mutation to create a {0}.\"\"\"
    {1} = graphene.Field(lambda: {0}, description="{0} created by this mutation.")
    
    class Arguments:
        input = {0}Input()
    
    def mutate(self, info, input):
        data = input_to_dictionary(input)
    
        {1} = Model{0}(**data)
        db_session.add({1})
        db_session.commit()
    
        return Create{0}({1}={1})
               """.format(util.convertSnackToPascal(model_name), util.convertSnackToCamel(model_name))


# Todo: implement filter builder
def buildMutationUpdate(model_name):
    return """\n\nclass Create{0}(graphene.Mutation):
    \"\"\"Mutation to update a {0}.\"\"\"
    {1} = graphene.Field(lambda: {0}, description="{0} updated by this mutation.")

    class Arguments:
        input = {0}Input()
        where = {0}Input()

    def mutate(self, info, input, filter_condition):
        input_data = input_to_dictionary(input)
        filter_join = input_to_dictionary(filter_condition)
        
        query = {0}.get_query(info)
        {1} = query.filter(and_({0}.id == authority_id)).first()
        
        {1} = {0}.objects.get(pk=data['id'])
        db_session.add({1})
        db_session.commit()

        return Create{0}({1}={1})
               """.format(util.convertSnackToPascal(model_name), util.convertSnackToCamel(model_name))


def convertSqlDataTypeToGrapheneType(sql_data_type):
    switcher = {
        "int": "Int",
        "tinyint": "Int",
        "smallint": "Int",
        "bigint": "Int",
        "varchar": "String",
        "datetime": "DateTime",
        "decimal": "Decimal",
        "text": "String",
        "longtext": "String"
    }
    return switcher.get(sql_data_type, "Invalid sql data type")


def buildSchemaFile(table_name, cursor):
    schema_content = []

    model_name = util.convertSnackToPascal(table_name)
    import_packages = ["from {0}.model_{1} import Model{2}".format(config.model_folder, table_name,
                                                                   model_name)]
    queries_class = ["class Query:"]
    mutation_class = ["class Mutation:"]

    schema_content.append("\n\n" + buildInputs(import_packages, model_name, cursor, queries_class))
    schema_content.append(buildMetaNode(model_name))
    schema_content.append(buildConnection(model_name))
    schema_content.append(buildMutationInsert(table_name))

    mutation_class.append("\n\tcreate{0} = Create{0}.Field()".format(model_name))

    queries_class.append(buildQueryBySQLAlchemyConnectionField(table_name))
    content = "\n".join(common_import + import_packages + schema_content + queries_class + mutation_class)
    return content


def outSchemaFile(table_name, content_schema):
    f = open("{0}/schema_{1}.py".format(config.schema_folder, table_name), "w+")
    f.write(util.black.format_str(content_schema, mode=util.black.FileMode()))
    f.close()


for (table_name,) in generate_cursor.cursor:
    if len(config.list_tables) == 0 or table_name in config.list_tables:
        generate_cursor.cursor.execute(generate_cursor.query_column_info.format(table_name))
        outSchemaFile(table_name, buildSchemaFile(table_name, generate_cursor.cursor))
