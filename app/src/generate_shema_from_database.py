import MySQLdb
import inspect

import generate_config as config
import generate_util as util
import generate_cursor

common_import = ["""
# The file has been generated by tool- nguyennt2@rikkeisoft.com

import graphene
from datetime import datetime
from graphene_sqlalchemy import SQLAlchemyObjectType
from config.database import db_session
from common.util.graphene_util import input_to_dictionary
\n
"""]


def buildInputs(import_packages, model_name, cursor):

    content_attribute = [
        """#Create a generic class to mutualize description of people attributes for both queries and mutations
           class {}Attribute(graphene.InputObjectType):""".format(model_name)
    ]
    for (column_name, data_type, character_maximum_length, numeric_precision, numeric_scale, is_nullable, extra,
         column_comment, column_key, column_default) in cursor:
        content_attribute.append(
            '{0} = graphene.{1}(description="{2}", require={3})'.format(column_name, data_type.title(), column_comment,
                                                                        'false'))

        # create new connection cursor for getting constraint information
        cursor_key_column_usage = generate_cursor.connection.cursor(MySQLdb.cursors.DictCursor)  # get the cursor
        cursor_key_column_usage.execute(generate_cursor.query_constraint.format(column_name, table_name))
        constraint_info = cursor_key_column_usage.fetchone()  # get only row

        if constraint_info is not None:
            referenced_model = constraint_info['referenced_table_name']
            import_packages.append('from schemas.schema_{0} import {1}'.format(table_name, referenced_model))
            content_attribute.append('{0} = graphene.Field({1})'.format(table_name, referenced_model))

    return "\n".join(content_attribute)


def buildSchemaFile(table_name, cursor):

    schemaContent = []

    import_packages = []

    schema_file = "schema_{0}.py".format(table_name)
    f = open(config.schema_folder + "/" + schema_file, "w+")
    model_name = util.convertSnackToPascal(table_name)
    import_packages.append("from models.model_{0} import Model{1}".format(table_name, model_name))

    schemaContent.append(buildInputs(import_packages, model_name, cursor))

    content = """
            # Create a generic class to mutualize description of people attributes for both queries and mutations
            class {0}Attribute:
                # example to create attribute name
                name = graphene.String(description="Name of the {0}.")


            class {0}(SQLAlchemyObjectType):
                \"\"\"{0} node.\"\"\"

                class Meta:
                    model = Model{0}
                    interfaces = (graphene.relay.Node,)


            class Create{0}Input(graphene.InputObjectType, {0}Attribute):
                \"\"\"Arguments to create a {0}.\"\"\"
                pass


            class Create{0}(graphene.Mutation):
                \"\"\"Mutation to create a {0}.\"\"\"
                {1} = graphene.Field(lambda: {0}, description="{0} created by this mutation.")

                class Arguments:
                    input = Create{0}Input(required=True)

                def mutate(self, info, input):
                    data = input_to_dictionary(input)
                    data['created'] = datetime.utcnow()
                    data['edited'] = datetime.utcnow()

                    {1} = {0}(**data)
                    db_session.add({1})
                    db_session.commit()

                    return Create{0}({1}={1})


            class Update{0}Input(graphene.InputObjectType, {0}Attribute):
                \"\"\"Arguments to update a {0}.\"\"\"
                id = graphene.ID(required=True, description="Global Id of the {0}.")


            class Update{0}(graphene.Mutation):
                \"\"\"Update a person.\"\"\"
                {1} = graphene.Field(lambda: {0}, description="{0} updated by this mutation.")

                class Arguments:
                    input = Update{0}Input(required=True)

                def mutate(self, info, input):
                    data = input_to_dictionary(input)
                    data['edited'] = datetime.utcnow()

                    {1} = db_session.query({0}).filter_by(id=data['id'])
                    {1}.update(data)
                    db_session.commit()
                    {1} = db_session.query({0}).filter_by(id=data['id']).first()

                    return Update{0}({1}={1})""".format(util.convertSnackToPascal(class_name),
                                                        util.convertSnackToCamel(class_name), class_name)

    f.write(inspect.cleandoc(content))
    f.close()


def convertSqlDataTypeToGrapheneType(sql_data_type):
    switcher = {
        "int": "INTEGER",
        "tinyint": "TINYINT",
        "smallint": "SMALLINT",
        "bigint": "BIGINT",
        "varchar": "String",
        "datetime": "DateTime",
        "decimal": "DECIMAL",
        "text": "TEXT",
        "longtext": "LONGTEXT"
    }
    return switcher.get(sql_data_type, "Invalid sql data type")


def outModelFile(table_name, content_schema):
    f = open("{0}/schema_{1}.py".format(config.schema_folder, table_name), "w+")
    f.write(content_schema)
    f.close()


for (table_name,) in generate_cursor.cursor:
    if len(config.list_tables) == 0 or table_name in config.list_tables:
        generate_cursor.cursor.execute(generate_cursor.query_column_info.format(table_name))
        buildSchemaFile(table_name, buildSchema(table_name, generate_cursor.cursor))
