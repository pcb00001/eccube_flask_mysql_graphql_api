import MySQLdb
import inspect

import generate_config as config
import generate_util as util
import generate_cursor

common_import = ["""
# The file has been generated by tool- nguyennt2@rikkeisoft.com

import graphene
import sqlalchemy
from graphene_sqlalchemy import SQLAlchemyConnectionField
from datetime import datetime
from graphene_sqlalchemy import SQLAlchemyObjectType
from config.database import db_session
from common.util.graphene_util import input_to_dictionary
\n
"""]


def buildInputs(import_packages, model_name, cursor, queries_class, table_name):
    content_attribute = [
        "class {}Input(graphene.InputObjectType):".format(model_name)
    ]

    # build get all customize filter query
    queries_class.append(
        buildQueryAllNestedFilter(table_name))

    # build get first customize filter query
    queries_class.append(
        buildQueryFirstNestedFilter(table_name))

    # build customize filter with limit
    queries_class.append(
        buildQueryLimitNestedFilter(table_name))

    # build get all query
    queries_class.append(
        buildQueryAll(table_name))

    # build get all query
    queries_class.append(
        buildQueryFirst(table_name))

    # build filter with limit
    queries_class.append(
        buildQueryLimit(table_name))

    # build edges filter
    queries_class.append(buildQueryBySQLAlchemyConnectionField(table_name))

    for (column_name, data_type, character_maximum_length, numeric_precision, numeric_scale, is_nullable, extra,
         column_comment, column_key, column_default) in cursor:
        content_attribute.append(
            '\t{0} = graphene.{1}(description="{2}", require={3})'.format(column_name,
                                                                          convertSqlDataTypeToGrapheneType(data_type),
                                                                          column_comment,
                                                                          is_nullable == 'YES'))

        # create new connection cursor for getting constraint information
        cursor_key_column_usage = generate_cursor.connection.cursor(MySQLdb.cursors.DictCursor)  # get the cursor
        cursor_key_column_usage.execute(generate_cursor.query_constraint.format(column_name, table_name))
        constraint_info = cursor_key_column_usage.fetchone()  # get only one row

        # build count by column
        queries_class.append(
            buildQueryCountByColumnName(column_name, convertSqlDataTypeToGrapheneType(data_type), table_name))

        # build get by column
        queries_class.append(
            buildQueryAllByColumnName(column_name, convertSqlDataTypeToGrapheneType(data_type), table_name))

        # build get one by column
        queries_class.append(
            buildQueryFirstByColumnName(column_name, convertSqlDataTypeToGrapheneType(data_type), table_name))

        # build get by column with limit
        queries_class.append(
            buildQueryLimitByColumnName(column_name, convertSqlDataTypeToGrapheneType(data_type), table_name))

        # build filter like operator
        if convertSqlDataTypeToGrapheneType(data_type) == "String":
            queries_class.append(
                buildQueryAllByColumnNameLike(column_name, table_name))

            queries_class.append(
                buildQueryFirstByColumnNameLike(column_name, table_name))

            queries_class.append(
                buildQueryLimitByColumnNameLike(column_name, table_name))

            queries_class.append(
                buildQueryAllByColumnNameNotLike(column_name, table_name))

            queries_class.append(
                buildQueryFirstByColumnNameNotLike(column_name, table_name))

            queries_class.append(
                buildQueryLimitByColumnNameNotLike(column_name, table_name))

        # build filter between operator
        if convertSqlDataTypeToGrapheneType(data_type) == "Int":
            queries_class.append(
                buildQueryAllByColumnNameBetween(column_name, table_name))

            queries_class.append(
                buildQueryFirstByColumnNameBetween(column_name, table_name))

            queries_class.append(
                buildQueryLimitByColumnNameBetween(column_name, table_name))

            queries_class.append(
                buildQueryAllByColumnNameNotBetween(column_name, table_name))

            queries_class.append(
                buildQueryFirstByColumnNameNotBetween(column_name, table_name))

            queries_class.append(
                buildQueryLimitByColumnNameNotBetween(column_name, table_name))

        # build filter in operator
        queries_class.append(
            buildQueryAllByColumnNameIn(column_name, convertSqlDataTypeToGrapheneType(data_type), table_name))

        queries_class.append(
            buildQueryFirstByColumnNameIn(column_name, convertSqlDataTypeToGrapheneType(data_type), table_name))

        queries_class.append(
            buildQueryLimitByColumnNameIn(column_name, convertSqlDataTypeToGrapheneType(data_type), table_name))

        # build filter not-in operator
        queries_class.append(
            buildQueryAllByColumnNameNotIn(column_name, convertSqlDataTypeToGrapheneType(data_type), table_name))

        queries_class.append(
            buildQueryFirstByColumnNameNotIn(column_name, convertSqlDataTypeToGrapheneType(data_type), table_name))

        queries_class.append(
            buildQueryLimitByColumnNameNotIn(column_name, convertSqlDataTypeToGrapheneType(data_type), table_name))

        # build filter is null operator
        queries_class.append(
            buildQueryAllByColumnNameIsNull(column_name, table_name))

        queries_class.append(
            buildQueryFirstByColumnNameIsNull(column_name, table_name))

        queries_class.append(
            buildQueryLimitByColumnNameIsNull(column_name, table_name))

        # build filter is not null operator
        queries_class.append(
            buildQueryAllByColumnNameIsNotNull(column_name, table_name))

        queries_class.append(
            buildQueryFirstByColumnNameIsNotNull(column_name, table_name))

        queries_class.append(
            buildQueryLimitByColumnNameIsNotNull(column_name, table_name))

        if constraint_info is not None:
            referenced_table_name = constraint_info['referenced_table_name']
            if table_name != referenced_table_name:
                import_packages.append('from {2}.schema_{0} import {1}Input'.format(referenced_table_name,
                                                                                    util.convertSnackToPascal(
                                                                                        referenced_table_name),
                                                                                    config.schema_folder))

                # import_packages.append('from {2}.model_{0} import Model{1}'.format(referenced_table_name,
                #                                                                    util.convertSnackToPascal(
                #                                                                        referenced_table_name),
                #                                                                    config.model_folder))
                content_attribute.append(
                    '\n\tmodel_{0} = graphene.Field({1}Input)'.format(referenced_table_name, util.convertSnackToPascal(
                        referenced_table_name)))

    return "\n".join(content_attribute)


def buildConnection(model_name):
    return inspect.cleandoc("""
    \n\nclass {0}Connections(graphene.relay.Connection):
        class Meta:
            node = {0}""".format(model_name))


def buildMetaNode(model_name):
    return inspect.cleandoc("""
    \n\nclass {0}(SQLAlchemyObjectType):
        class Meta:
            model = Model{0}
            interfaces = (graphene.relay.Node,)
    """.format(model_name))

def buildQueryCountByColumnName(input_name, data_type, return_type):
    return (
        "\n count_{3}_by_{0} = graphene.Field(graphene.Int, {0}=graphene.{1}())"
        "\n def resolve_count_{3}_by_{0}(self, info, {0}):"
        "\n     query = {2}.get_query(info)"
        "\n     rs = query.filter(Model{2}.{0} == {0}).count()"
        "\n     return rs"
    ).format(input_name, data_type, util.convertSnackToPascal(return_type), return_type)

def buildQueryAllByColumnName(input_name, data_type, return_type):
    return (
        "\n get_all_{3}_by_{0} = graphene.Field(lambda: graphene.List({2}), {0}=graphene.{1}())"
        "\n def resolve_get_all_{3}_by_{0}(self, info, {0}):"
        "\n     query = {2}.get_query(info)"
        "\n     return query.filter(Model{2}.{0} == {0}).all()"
    ).format(input_name, data_type, util.convertSnackToPascal(return_type), return_type)


def buildQueryFirstByColumnName(input_name, data_type, return_type):
    return (
        "\n get_first_{3}_by_{0} = graphene.Field({2}, {0}=graphene.{1}())"
        "\n def resolve_get_first_{3}_by_{0}(self, info, {0}):"
        "\n     query = {2}.get_query(info)"
        "\n     return query.filter(Model{2}.{0} == {0}).first()"
    ).format(input_name, data_type, util.convertSnackToPascal(return_type), return_type)


def buildQueryLimitByColumnName(input_name, data_type, return_type):
    return (
        "\n get_limit_{3}_by_{0} = graphene.Field(lambda: graphene.List({2}), {0}=graphene.{1}(),"
        "\n offset=graphene.Int(), limit=graphene.Int())"
        "\n def resolve_get_limit_{3}_by_{0}(self, info, {0}, offset, limit):"
        "\n     query = {2}.get_query(info)"
        "\n     return query.filter(Model{2}.{0} == {0}).offset(offset).limit(limit).all()"
    ).format(input_name, data_type, util.convertSnackToPascal(return_type), return_type)


def buildQueryAllByColumnNameLike(input_name, return_type):
    return (
        "\n get_all_{2}_by_{0}_like = graphene.Field(lambda: graphene.List({1}), {0}=graphene.String())"
        "\n def resolve_get_all_{2}_by_{0}_like(self, info, {0}):"
        "\n     query = {1}.get_query(info)"
        "\n     return query.filter(Model{1}.{0}.like({0})).all()"
    ).format(input_name, util.convertSnackToPascal(return_type), return_type)


def buildQueryFirstByColumnNameLike(input_name, return_type):
    return (
        "\n get_first_{2}_by_{0}_like = graphene.Field({1}, {0}=graphene.String())"
        "\n def resolve_get_first_{2}_by_{0}_like(self, info, {0}):"
        "\n     query = {1}.get_query(info)"
        "\n     return query.filter(Model{1}.{0}.like({0})).first()"
    ).format(input_name, util.convertSnackToPascal(return_type), return_type)


def buildQueryLimitByColumnNameLike(input_name, return_type):
    return (
        "\n get_limit_{2}_by_{0}_like = graphene.Field(lambda: graphene.List({1}), {0}=graphene.String(),"
        "\n offset=graphene.Int(), limit=graphene.Int())"
        "\n def resolve_get_limit_{2}_by_{0}_like(self, info, {0}, offset, limit):"
        "\n     query = {1}.get_query(info)"
        "\n     return query.filter(Model{1}.{0}.like({0})).offset(offset).limit(limit).all()"
    ).format(input_name, util.convertSnackToPascal(return_type), return_type)


def buildQueryAllByColumnNameNotLike(input_name, return_type):
    return (
        "\n get_all_{2}_by_{0}_like = graphene.Field(lambda: graphene.List({1}), {0}=graphene.String())"
        "\n def resolve_get_all_{2}_by_{0}_not_like(self, info, {0}):"
        "\n     query = {1}.get_query(info)"
        "\n     return query.filter(Model{1}.{0}.notlike({0})).all()"
    ).format(input_name, util.convertSnackToPascal(return_type), return_type)


def buildQueryFirstByColumnNameNotLike(input_name, return_type):
    return (
        "\n get_first_{2}_by_{0}_like = graphene.Field({1}, {0}=graphene.String())"
        "\n def resolve_get_first_{2}_by_{0}_not_like(self, info, {0}):"
        "\n     query = {1}.get_query(info)"
        "\n     return query.filter(Model{1}.{0}.notlike({0})).first()"
    ).format(input_name, util.convertSnackToPascal(return_type), return_type)


def buildQueryLimitByColumnNameNotLike(input_name, return_type):
    return (
        "\n get_limit_{2}_by_{0}_like = graphene.Field(lambda: graphene.List({1}), {0}=graphene.String(),"
        "\n offset=graphene.Int(), limit=graphene.Int())"
        "\n def resolve_get_limit_{2}_by_{0}_not_like(self, info, {0}, offset, limit):"
        "\n     query = {1}.get_query(info)"
        "\n     return query.filter(Model{1}.{0}.notlike({0})).offset(offset).limit(limit).all()"
    ).format(input_name, util.convertSnackToPascal(return_type), return_type)


def buildQueryAllByColumnNameIn(input_name, data_type, return_type):
    return (
        "\n get_all_{3}_by_{0}_in = graphene.Field(lambda: graphene.List({2}), {0}=graphene.List(graphene.{1}))"
        "\n def resolve_get_all_{3}_by_{0}_in(self, info, {0}):"
        "\n     query = {2}.get_query(info)"
        "\n     return query.filter(Model{2}.{0}.in_({0})).all()"
    ).format(input_name, data_type, util.convertSnackToPascal(return_type), return_type)


def buildQueryFirstByColumnNameIn(input_name, data_type, return_type):
    return (
        "\n get_first_{3}_by_{0}_in = graphene.Field({2},  {0}=graphene.List(graphene.{1}))"
        "\n def resolve_get_first_{3}_by_{0}_in(self, info, {0}):"
        "\n     query = {2}.get_query(info)"
        "\n     return query.filter(Model{2}.{0}.in_({0})).first()"
    ).format(input_name, data_type, util.convertSnackToPascal(return_type), return_type)


def buildQueryLimitByColumnNameIn(input_name, data_type, return_type):
    return (
        "\n get_limit_{3}_by_{0}_in = graphene.Field(lambda: graphene.List({2}), {0}=graphene.List(graphene.{1}), "
        "\n offset=graphene.Int(), limit=graphene.Int())"
        "\n def resolve_get_limit_{3}_by_{0}_in(self, info, {0}, offset, limit):"
        "\n     query = {2}.get_query(info)"
        "\n     return query.filter(Model{2}.{0}.in_({0})).offset(offset).limit(limit).all()"
    ).format(input_name, data_type, util.convertSnackToPascal(return_type), return_type)


def buildQueryAllByColumnNameNotIn(input_name, data_type, return_type):
    return (
        "\n get_all_{3}_by_{0}_not_in = graphene.Field(lambda: graphene.List({2}), {0}=graphene.List(graphene.{1}))"
        "\n def resolve_get_all_{3}_by_{0}_not_in(self, info, {0}):"
        "\n     query = {2}.get_query(info)"
        "\n     return query.filter(Model{2}.{0}.notin_({0})).all()"
    ).format(input_name, data_type, util.convertSnackToPascal(return_type), return_type)


def buildQueryFirstByColumnNameNotIn(input_name, data_type, return_type):
    return (
        "\n get_first_{3}_by_{0}_not_in = graphene.Field({2},  {0}=graphene.List(graphene.{1}))"
        "\n def resolve_get_first_{3}_by_{0}_not_in(self, info, {0}):"
        "\n     query = {2}.get_query(info)"
        "\n     return query.filter(Model{2}.{0}.notin_({0})).first()"
    ).format(input_name, data_type, util.convertSnackToPascal(return_type), return_type)


def buildQueryLimitByColumnNameNotIn(input_name, data_type, return_type):
    return (
        "\n get_limit_{3}_by_{0}_not_in = graphene.Field(lambda: graphene.List({2}), {0}=graphene.List(graphene.{1}),"
        "\n offset=graphene.Int(), limit=graphene.Int())"
        "\n def resolve_get_limit_{3}_by_{0}_not_in(self, info, {0}, offset, limit):"
        "\n     query = {2}.get_query(info)"
        "\n     return query.filter(Model{2}.{0}.notin_({0})).offset(offset).limit(limit).all()"
    ).format(input_name, data_type, util.convertSnackToPascal(return_type), return_type)


def buildQueryAllByColumnNameBetween(input_name, return_type):
    return (
        "\n get_all_{2}_by_{0}_between = graphene.Field(lambda: graphene.List({1}),"
        "\n {0}_start=graphene.Int(), {0}_end=graphene.Int())"
        "\n def resolve_get_all_{2}_by_{0}_between(self, info, {0}_start, {0}_end):"
        "\n     query = {1}.get_query(info)"
        "\n     return query.filter(Model{1}.{0}.between({0}_start, {0}_end)).all()"
    ).format(input_name, util.convertSnackToPascal(return_type), return_type)


def buildQueryFirstByColumnNameBetween(input_name, return_type):
    return (
        "\n get_first_{2}_by_{0}_between = graphene.Field({1}, {0}_start=graphene.Int(), {0}_end=graphene.Int())"
        "\n def resolve_get_first_{2}_by_{0}_between(self, info, {0}_start, {0}_end):"
        "\n     query = {1}.get_query(info)"
        "\n     return query.filter(Model{1}.{0}.between({0}_start, {0}_end)).first()"
    ).format(input_name, util.convertSnackToPascal(return_type), return_type)


def buildQueryLimitByColumnNameBetween(input_name, return_type):
    return (
        "\n get_limit_{2}_by_{0}_between = graphene.Field(lambda: graphene.List({1}),"
        "\n {0}_start=graphene.Int(), {0}_end=graphene.Int(),"
        "\n offset=graphene.Int(), limit=graphene.Int())"
        "\n def resolve_get_limit_{2}_by_{0}_between(self, info, {0}_start, {0}_end, offset, limit):"
        "\n     query = {1}.get_query(info)"
        "\n     return query.filter(Model{1}.{0}.between({0}_start, {0}_end)).offset(offset).limit(limit).all()"
    ).format(input_name, util.convertSnackToPascal(return_type), return_type)


def buildQueryAllByColumnNameNotBetween(input_name, return_type):
    return (
        "\n get_all_{2}_by_{0}_not_between = graphene.Field(lambda: graphene.List({1}), {0}_start=graphene.Int(), {0}_end=graphene.Int())"
        "\n def resolve_get_all_{2}_by_{0}_not_between(self, info, {0}_start, {0}_end):"
        "\n     query = {1}.get_query(info)"
        "\n     return query.filter(sqlalchemy.not_(Model{1}.{0}.between({0}_start, {0}_end))).all()"
    ).format(input_name, util.convertSnackToPascal(return_type), return_type)


def buildQueryFirstByColumnNameNotBetween(input_name, return_type):
    return (
        "\n get_first_{2}_by_{0}_not_between = graphene.Field({1}, {0}_start=graphene.Int(), {0}_end=graphene.Int())"
        "\n def resolve_get_first_{2}_by_{0}_not_between(self, info, {0}_start, {0}_end):"
        "\n     query = {1}.get_query(info)"
        "\n     return query.filter(sqlalchemy.not_(Model{1}.{0}.between({0}_start, {0}_end))).first()"
    ).format(input_name, util.convertSnackToPascal(return_type), return_type)


def buildQueryLimitByColumnNameNotBetween(input_name, return_type):
    return (
        "\n get_limit_{2}_by_{0}_not_between = graphene.Field(lambda: graphene.List({1}),"
        "\n {0}_start=graphene.Int(), {0}_end=graphene.Int(),"
        "\n offset=graphene.Int(), limit=graphene.Int())"
        "\n def resolve_get_limit_{2}_by_{0}_not_between(self, info, {0}_start, {0}_end, offset, limit):"
        "\n     query = {1}.get_query(info)"
        "\n     return query.filter(sqlalchemy.not_(Model{1}.{0}.between({0}_start, {0}_end))).offset(offset).limit(limit).all()"
    ).format(input_name, util.convertSnackToPascal(return_type), return_type)


def buildQueryAll(return_type):
    return (
        "\n get_all_{1} = graphene.Field(lambda: graphene.List({0}))"
        "\n def resolve_get_all_{1}(self, info):"
        "\n     query = {0}.get_query(info)"
        "\n     return query.all()"
    ).format(util.convertSnackToPascal(return_type), return_type)


def buildQueryFirst(return_type):
    return (
        "\n get_first_{1} = graphene.Field(lambda: graphene.List({0}))"
        "\n def resolve_get_first_{1}(self, info):"
        "\n     query = {0}.get_query(info)"
        "\n     return query.first()"
    ).format(util.convertSnackToPascal(return_type), return_type)


def buildQueryLimit(return_type):
    return (
        "\n get_limit_{1} = graphene.Field(lambda: graphene.List({0}), offset=graphene.Int(), limit=graphene.Int())"
        "\n def resolve_get_limit_{1}(self, info, offset, limit):"
        "\n     query = {0}.get_query(info)"
        "\n     return query.offset(offset).limit(limit).all()"
    ).format(util.convertSnackToPascal(return_type), return_type)


def buildQueryAllByColumnNameIsNull(input_name, return_type):
    return (
        "\n get_all_{2}_by_{0}_is_null = graphene.Field(lambda: graphene.List({1}))"
        "\n def resolve_get_all_{2}_by_{0}_is_null(self, info):"
        "\n     query = {1}.get_query(info)"
        "\n     return query.filter(Model{1}.{0} == None).all()"
    ).format(input_name, util.convertSnackToPascal(return_type), return_type)


def buildQueryFirstByColumnNameIsNull(input_name, return_type):
    return (
        "\n get_first_{2}_by_{0}_is_null = graphene.Field({1})"
        "\n def resolve_get_first_{2}_by_{0}_is_null(self, info):"
        "\n     query = {1}.get_query(info)"
        "\n     return query.filter(Model{1}.{0} == None).first()"
    ).format(input_name, util.convertSnackToPascal(return_type), return_type)


def buildQueryLimitByColumnNameIsNull(input_name, return_type):
    return (
        "\n get_limit_{2}_by_{0}_is_null = graphene.Field(lambda: graphene.List({1}),"
        "\n offset=graphene.Int(), limit=graphene.Int())"
        "\n def resolve_get_limit_{2}_by_{0}_is_null(self, info, offset, limit):"
        "\n     query = {1}.get_query(info)"
        "\n     return query.filter(Model{1}.{0} == None).offset(offset).limit(limit).all()"
    ).format(input_name, util.convertSnackToPascal(return_type), return_type)


def buildQueryAllByColumnNameIsNotNull(input_name, return_type):
    return (
        "\n get_all_{2}_by_{0}_is_not_null = graphene.Field(lambda: graphene.List({1}))"
        "\n def resolve_get_all_{2}_by_{0}_is_not_NotNull(self, info):"
        "\n     query = {1}.get_query(info)"
        "\n     return query.filter(Model{1}.{0} != None).all()"
    ).format(input_name, util.convertSnackToPascal(return_type), return_type)


def buildQueryFirstByColumnNameIsNotNull(input_name, return_type):
    return (
        "\n get_first_{2}_by_{0}_is_not_null = graphene.Field({1})"
        "\n def resolve_get_first_{2}_by_{0}_is_not_NotNull(self, info):"
        "\n     query = {1}.get_query(info)"
        "\n     return query.filter(Model{1}.{0} != None).first()"
    ).format(input_name, util.convertSnackToPascal(return_type), return_type)


def buildQueryLimitByColumnNameIsNotNull(input_name, return_type):
    return (
        "\n get_limit_{2}_by_{0}_is_not_null = graphene.Field(lambda: graphene.List({1}),"
        "\n offset=graphene.Int(), limit=graphene.Int())"
        "\n def resolve_get_limit_{2}_by_{0}_is_not_NotNull(self, info, offset, limit):"
        "\n     query = {1}.get_query(info)"
        "\n     return query.filter(Model{1}.{0} != None).offset(offset).limit(limit).all()"
    ).format(input_name, util.convertSnackToPascal(return_type), return_type)


def buildQueryAllNestedFilter(return_type):
    return (
        "\n get_all_{1}_nested_filter = graphene.Field(lambda: graphene.List({0}), input={0}Input())"
        "\n def resolve_get_all_{1}_nested_filter(self, info, input):"
        "\n     query = {0}.get_query(info)"
        "\n     return query.all()"
    ).format(util.convertSnackToPascal(return_type), return_type)


def buildQueryFirstNestedFilter(return_type):
    return (
        "\n get_first_{1}_nested_filter = graphene.Field(lambda: graphene.List({0}), input={0}Input())"
        "\n def resolve_get_first_{1}_nested_filter(self, info, input):"
        "\n     query = {0}.get_query(info)"
        "\n     return query.first()"
    ).format(util.convertSnackToPascal(return_type), return_type)


def buildQueryLimitNestedFilter(return_type):
    return (
        "\n get_limit_{1}_nested_filter = graphene.Field(lambda: graphene.List({0}), input={0}Input(), offset=graphene.Int(), limit=graphene.Int())"
        "\n def resolve_get_limit_{1}_nested_filter(self, info, input, offset, limit):"
        "\n     query = {0}.get_query(info)"
        "\n     return query.offset(offset).limit(limit).all()"
    ).format(util.convertSnackToPascal(return_type), return_type)


def buildQueryBySQLAlchemyConnectionField(return_type):
    return (
        "\n edges_{1} = SQLAlchemyConnectionField({0}Connections)"
    ).format(util.convertSnackToPascal(return_type), return_type)


def buildMutationInsert(model_name):
    return """\n\nclass Create{0}(graphene.Mutation):
    \"\"\"Mutation to create a {0}.\"\"\"
    {1} = graphene.Field(lambda: {0}, description="{0} created by this mutation.")
    
    class Arguments:
        input = {0}Input()
    
    def mutate(self, info, input):
        data = input_to_dictionary(input)
    
        {1} = Model{0}(**data)
        db_session.add({1})
        db_session.commit()
    
        return Create{0}({1}={1})
               """.format(util.convertSnackToPascal(model_name), util.convertSnackToCamel(model_name))


# Todo: implement filter builder
def buildMutationUpdate(model_name):
    return """\n\nclass Create{0}(graphene.Mutation):
    \"\"\"Mutation to update a {0}.\"\"\"
    {1} = graphene.Field(lambda: {0}, description="{0} updated by this mutation.")

    class Arguments:
        input = {0}Input()
        where = {0}Input()

    def mutate(self, info, input, filter_condition):
        input_data = input_to_dictionary(input)
        filter_join = input_to_dictionary(filter_condition)
        
        query = {0}.get_query(info)
        {1} = query.filter(and_({0}.id == authority_id)).first()
        
        {1} = {0}.objects.get(pk=data['id'])
        db_session.add({1})
        db_session.commit()

        return Create{0}({1}={1})
               """.format(util.convertSnackToPascal(model_name), util.convertSnackToCamel(model_name))


def convertSqlDataTypeToGrapheneType(sql_data_type):
    switcher = {
        "int": "Int",
        "tinyint": "Int",
        "smallint": "Int",
        "bigint": "Int",
        "varchar": "String",
        "datetime": "DateTime",
        "decimal": "Decimal",
        "text": "String",
        "longtext": "String"
    }
    return switcher.get(sql_data_type, "Invalid sql data type")


def buildSchemaFile(table_name, cursor):
    schema_content = []

    model_name = util.convertSnackToPascal(table_name)
    import_packages = ["from {0}.model_{1} import Model{2}".format(config.model_folder, table_name,
                                                                   model_name)]
    queries_class = ["class Query:"]

    schema_content.append("\n\n" + buildInputs(import_packages, model_name, cursor, queries_class, table_name))
    schema_content.append(buildMetaNode(model_name))
    schema_content.append(buildConnection(model_name))

    # Todo: implement mutation
    # mutation_class = ["class Mutation:"]
    # mutation_class.append("\n\tcreate{0} = Create{0}.Field()".format(model_name))
    # content = "\n".join(common_import + import_packages + schema_content + queries_class + mutation_class)
    # schema_content.append(buildMutationInsert(table_name))
    content = "\n".join(common_import + import_packages + schema_content + queries_class)

    return content


def outSchemaFile(table_name, content_schema):
    f = open("{0}/schema_{1}.py".format(config.schema_folder, table_name), "w+")
    f.write(util.black.format_str(content_schema, mode=util.black.FileMode()))
    f.close()


for (table_name,) in generate_cursor.cursor:
    if len(config.list_tables) == 0 or table_name in config.list_tables:
        generate_cursor.cursor.execute(generate_cursor.query_column_info.format(table_name))
        outSchemaFile(table_name, buildSchemaFile(table_name, generate_cursor.cursor))
